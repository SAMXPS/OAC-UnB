# Esse arquivo é um formato customizado que irá gerar meu instruction_set.
#name   t   opcode      fun3    funct7      code
#
add     R   0b0110011   0b000   0b0000000   "{registers[rd]=registers[rs1]+registers[rs2];}"
and     R   0b0110011   0b111   0b0000000   "{registers[rd]=registers[rs1]&registers[rs2];}"
or      R   0b0110011   0b110   0b0000000   "{registers[rd]=registers[rs1]|registers[rs2];}"
sub     R   0b0110011   0b000   0b0100000   "{registers[rd]=registers[rs1]-registers[rs2];}"
xor     R   0b0110011   0b100   0b0000000   "{registers[rd]=registers[rs1]^registers[rs2];}"
addi    I   0b0010011   0b000   0b0000000   "{registers[rd]=registers[rs1]+imm;}"
andi    I   0b0010011   0b111   0b0000000   "{registers[rd]=registers[rs1]&imm;}"
ori     I   0b0010011   0b110   0b0000000   "{registers[rd]=registers[rs1]|imm;}"
auipc   U   0b0010111   0b000   0b0000000   "{registers[rd]=imm+(pc-4);}"
lui     U   0b0110111   0b000   0b0000000   "{registers[rd]=imm;}"
beq     B   0b1100011   0b000   0b0000000   "{pc += (registers[rs1]==registers[rs2])*(imm-4);}"
bne     B   0b1100011   0b001   0b0000000   "{pc += (registers[rs1]!=registers[rs2])*(imm-4);}"
bge     B   0b1100011   0b101   0b0000000   "{pc += (( int32_t) registers[rs1] >= ( int32_t)registers[rs2])*(imm-4);}"
bgeu    B   0b1100011   0b111   0b0000000   "{pc += ((uint32_t) registers[rs1] >= (uint32_t)registers[rs2])*(imm-4);}"
blt     B   0b1100011   0b100   0b0000000   "{pc += (( int32_t) registers[rs1] <  ( int32_t)registers[rs2])*(imm-4);}"
bltu    B   0b1100011   0b110   0b0000000   "{pc += ((uint32_t) registers[rs1] <  (uint32_t)registers[rs2])*(imm-4);}"
jal     J   0b1101111   0b000   0b0000000   "{registers[rd]=pc;pc+=(imm-4);}"
jalr    I   0b1100111   0b000   0b0000000   "{registers[rd]=pc;pc=(registers[rs1]+imm)&0xFFFFFFFE;}"
lb      I   0b0000011   0b000   0b0000000   "{registers[rd]=(( int8_t*)mem)[registers[rs1] + imm];}"
lbu     I   0b0000011   0b100   0b0000000   "{registers[rd]=((uint8_t*)mem)[registers[rs1] + imm];}"
lw      I   0b0000011   0b010   0b0000000   "{registers[rd]=mem[(registers[rs1] + imm)/4];}"
sb      S   0b0100011   0b000   0b0000000   "{((uint8_t*)mem)[registers[rs1] + imm]=registers[rs2]&0xFF;}"
sw      S   0b0100011   0b010   0b0000000   "{((uint32_t*)mem)[(registers[rs1] + imm)/4]=registers[rs2];}"
sltu    R   0b0110011   0b011   0b0000000   "{registers[rd]=((uint32_t) registers[rs1] < (uint32_t)registers[rs2]);}"
slt     R   0b0110011   0b010   0b0000000   "{registers[rd]=(( int32_t) registers[rs1] < ( int32_t)registers[rs2]);}"
slli    R   0b0010011   0b001   0b0000000   "{registers[rd]=registers[rs1]<<rs2;}"
srli    R   0b0010011   0b101   0b0000000   "{registers[rd]=registers[rs1]>>rs2;}"
srai    R   0b0010011   0b101   0b0100000   "{registers[rd]=(uint32_t)((int32_t)registers[rs1]>>rs2);}"
ecall   I   0b1110011   0b000   0b0000000   "{ecall();}"